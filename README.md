# Cpp_Design_Pattern

# 2023.10.04

# Mediator Pattern

<중재자 패턴>

모든 클래스간의 복잡한 로직(상호작용)을 캡슐화하여 하나의 클래스에 위임하여 처리하는 패턴 M:N의 관계에서 M:1의 관계로 복잡도를 떨어뜨려 유지 보수 및 재사용의 확장성에 유리하다. 하나의 클래스가 떠맡아 처리해야 하므로 God(신) 클래스가 될 수 있으므로 주의해야 한다. 비슷한 패턴으로 퍼샤드(Facade) 패턴과 옵저버(Observer) 패턴이 있다.

# 2023.10.05

# Iterator Pattern

<반복자 패턴>

Iterator pattern은 리스트/스택/트리 등 자료구조를 노출하지 않고 내부의 모든 항목에 접근할 수 있게 해주는 방법을 제공하는 패턴, 반복자 패턴이라고도 하며 쉽게 이야기하면 접근기능과 자료구조를 분리하여 객체화

->Collection의 예시로 들었을 때. Collection은 단순한 container에 불과함
->그러나 Collection과는 관계없이, 다른 코드가 해당 elements를 사용할 수 있도록 액세스하는 방법을 제공해야 한다.

->이 때 iterator 패턴을 사용하여 여러 search alg를 구현하여 사용
->각 search alg는 동일한 interface를 가지고 있으며 이렇게 하면 iterator라고 불리는 별도의 object로 collection의 순회 동작 추출 가능
->여러 iterator object들은 동시에 동일한 collection을 이동 가능

*구성

->iterator interface: Collection통과에 필요한 작업을 선언(현재 위치 검색/ 반복 다시 시작 등)
->Concrete iterator: 컬렉션을 통과하기 위한 특정 알고리즘 구현(여러 반복자가 동일한 컬렉션을 이동할 수 있게)
->Collection interface:컬렉션과 호환되는 iterator를 얻기 위한 하나 이상의 method 선언
->Concrete collection: Client가 요청할 때 마다 특정 concrete iterator class의 새 instance를 반환
->Client: interface를 통해 collection혹은 iterator와 함께 작동


*구현

->iterator interface를 선언한 다음 collection에서 next element를 가져오는 method가 필요함
->collection interface를 선언하고 fetching iterator를 가져오는 method선언
->iterator를 사용하여 통과할 수 있는 collection에 대해 구체적인 iterator class 선언
->collection class에 collection interface 구현
->client code를 검토하여 모든 traversal code를 iterator 사용으로 변경

*장단점

-장점
->단일 책임 원칙 준수
->개방/폐쇄 원칙 준수
->각 iterator object는 고유한 반복 상태를 포함하기 때문에 동일한 collection에 대해 parrellel로 반복 가능
->같은 이유로 iteration을 지연시키고 필요할 때 continue 가능

추상화: 반복자는 컬렉션의 내부 구조에 대한 상세 정보를 숨기고, 클라이언트에게 단순화된 인터페이스를 제공한다. 이로 인해 클라이언트 코드는 컬렉션의 구현 세부사항에 의존하지 않게 되므로, 변경에 대한 영향을 최소화할 수 있다.

다형성: 같은 반복자 인터페이스를 사용하여 다양한 종류의 컬렉션을 순회할 수 있다. 예를 들어, 배열이나 리스트, 트리 등 다른 데이터 구조도 동일한 방식으로 접근할 수 있다.

모듈성: 컬렉션과 그것을 순회하는 로직이 분리되므로, 각각 독립적으로 수정하거나 확장하기 쉽다.

여러 반복: 한 컬렉션에 대해 여러 개의 반복자를 동시에 사용할 수 있다. 이는 알고리즘에서 유용하게 사용될 수 있는데, 예를 들어 두 개의 포인터가 서로 다른 속도로 움직여야 하는 "두 포인터" 알고리즘에서 이런 기능이 필요하다.

일관된 방식으로 요소 접근: 모든 타입의 컬렉션이 공통된 인터페이스를 가지게 되므로 프로그램 전체에서 일관된 방식으로 요소들을 접근할 수 있게 된다.
제어 흐름의 단순화: 일반적인 for-loop나 while-loop보다 반복자가 제공하는 메서드(hasNext, next 등)를 사용함으로써 제어 흐름을 더욱 단순하게 만들 수 있다.

*추상화에 대한 분석

"내부 구조를 숨긴다"는 말은 데이터 구조의 내부 동작 방식이나 구현 세부사항을 외부에서 알 수 없도록 추상화하는 것을 의미한다. 이는 캡슐화(encapsulation)라는 객체 지향 프로그래밍의 핵심 원칙 중 하나를 반영한 것이다.

예를 들어, 배열, 연결 리스트, 트리 등은 모두 컬렉션(collection)으로서 여러 요소들을 저장하고 관리하는 역할을 하지만, 각각의 내부 구조와 동작 방식은 다르다. 배열은 인덱스를 통해 빠른 접근이 가능하지만, 연결 리스트는 순차적인 접근이 필요하며, 트리는 계층적인 구조로 데이터에 접근합니다.

반복자 패턴을 사용하면 이런 세부적인 차이점들을 클라이언트 코드로부터 숨길 수 있다. 즉, 반복자가 제공하는 next(), hasNext() 등의 메서드를 통해 컬렉션의 요소들에 일관되게 접근할 수 있게 된다. 이로 인해 클라이언트 코드는 컬렉션이 어떤 종류인지, 어떻게 동작하는지 알 필요 없이 해당 컬렉션에 있는 모든 요소들을 순회할 수 있다.

따라서 "내부 구조를 숨긴다"는 것은 클라이언트 코드가 데이터 구조의 내부 동작 방식과 세부사항에 의존하지 않도록 만드는 것으로서, 코드의 유연성과 재사용성을 높여준다.

-단점
->프로그램이 간단한 collection에서 작동할 때에는 과할 수 있다.
->iterator을 사용하는 것은 일부 specialized collection에서는 비효율적일 수 있다.


# Singleton Pattern

<싱글톤 패턴>

싱글톤 패턴은 특정 클래스의 인스턴스가 하나만 생성되도록 보장하고, 그 인스턴스에 대한 전역적인 접근점을 제공하는 디자인 패턴이다. 이는 공유 리소스나 서비스 제공 객체 등에 유용하게 사용된다.

*장점

1.인스턴스 제어

싱글톤 패턴을 사용하면 시스템에서 클래스의 인스턴스가 단 하나만 존재함을 보장한다. 이는 데이터베이스 연결, 파일 시스템, 네트워크 리소스 등과 같이 한 번에 하나의 인스턴스만 존재해야 하는 경우에 유용하다.

2.전역 접근

싱글톤 객체는 전역적으로 접근 가능하기 때문에, 어디서든지 필요할 때 해당 객체를 사용할 수 있다.

3.메모리 절약

인스턴스가 필요할 때마다 생성하는 것이 아니라 이미 생성된 인스턴스를 재사용하므로 메모리 사용량을 줄일 수 있다.

4.공유 상태

여러 곳에서 공유해야 하는 데이터나 상태를 관리하는데 유용하다.

5. 상속 가능: 다른 클래스들이 싱글톤 클래스를 상속받아 새로운 종류의 싱글톤 클래스를 만들 수 있다.

*Lazy Initailization

Lazy Initialization이란 객체의 생성, 데이터의 계산, 또는 일부 복잡한 처리를 실제로 필요한 시점까지 미루는 기법을 말한다. 이 방식은 프로그램의 시작 시간을 줄이거나, 사용하지 않는 리소스의 생성을 피하거나, 필요할 때만 리소스를 사용하여 메모리를 절약하는 등의 이점을 제공한다.

예를 들어, 데이터베이스 연결 객체가 프로그램 시작 시점에 만들어진다면 프로그램 실행 초기에 상당한 오버헤드가 발생할 수 있다. 그러나 Lazy Initialization 방식으로 데이터베이스 연결 객체를 처음으로 데이터베이스에 쿼리를 요청하는 시점에서 생성한다면 이런 오버헤드를 피할 수 있다.

싱글톤 패턴에서도 Lazy Initialization 방식은 자주 사용된다. 싱글톤 인스턴스가 많은 리소스를 사용하거나 복잡한 초기화 과정이 필요하다면 프로그램 시작 시 모든 싱글톤 인스턴스가 초기화되는 것은 비효율적일 수 있다. 따라서 싱글톤 인스턴트는 처음으로 getInstance() 메서드가 호출되는 시점에서 생성되도록 할 수 있으며, 이렇게 하면 불필요한 리소르 소비를 최소화할 수 있다.

그러나 Lazy Initialization 기법 역시 주의해서 사용해야 한다. 멀티 스레딩 환경에서 동기화 문제로 인해 예상치 못한 버그가 발생할 가능성이 있으므로 적절한 동기화 조치가 필요하다.

# Abstract Factory Pattern

서로 관련이 있는 객체들을 Factory class로 만들고, 이 Factory class를 조건에 따라 생성하도록 Factory를 만드는 패턴

*예시

->가구 가게 시뮬레이터를 만든다고 가정

->관련 제품군은 chair /sofa /coffee table임

->관련 종류는 art Deco/ victorian / Modern

->같은 종류의 다른 물건과 일치하도록 물건을 만드는 방법이 필요하며, 손님은 짝이 맞지 않으면 화를 냄

->프로그램에 새 제품 및 제품군 추가시 기존 코드를 변경하지 않는 것이 좋음

->이럴 때 추상 팩토리 패턴을 사용

제품군의 제품에 대한 인터페이스를 명시적 사용

모든 제품에 대한 생성 방법 목록이 포함된 Abstract Factory를 선언

AbstractFactory 인터페이스를 기반으로 별도의 Factory class 생성

*구성

->Abstract Product: 제품군을 구성하는 고유하지만 관련 제품군에 대한 인터페이스 선언

-> Concrete Product: Abstract Product를 만드는 Method 제공

->Abstract Factory interface : Abstract Product를 만드는 Method 제공

-> Concrete Factory interface: Abstract Factory의 생성 Method 제공

*구현

->개별 제품 유형의 매트릭스 작성

->모든 제품에 대해 Abstract product interface

->모든 Abstract product에 대한 생성 방법을 사용하여 Abstract factory interface 선언

->각 제품 모델에 대해 구체적인 Factory class 세트를 구현

->Factory 초기화 코드 제작

->Product 생성자에 대한 모든 call을 찾음

*장점

추상 팩토리는 “제품 가족”이라고 할 수 있는 일련의 관련 제품을 함께 생성하는 데 유용하며, 클라이언트 코드가 특정 구현에 의존하지 않도록 도와준다. 그 결과 클라이언트 코드는 추상화된 인터페이스만 알면 되므로 변경에 대해 더 유연하게 대응할 수 있다.

그러나 추상 팩토리가 새로운 종류의 제품을 지원하기 어렵다는 단점도 있다. 새로운 종류의 제품을 추가하려면 모든 기존 추상 팩토리와 구체적인 팩토리 클래스에 새로운 생산 메소드를 추가해야 하기 때문이다.
